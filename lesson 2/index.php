Задание №1.
1. Порождающие шаблоны проектирования (Creational) - отвечают за удобное и безопасное создание новых объектов или даже целых семейств объектов.
  1.1. Абстрактная фабрика (Abstract Factory)
  1.2. Строитель (Builder)
  1.3. Фабричный Метод (Factory Method)
  1.4. Пул одиночек (Multiton)
  1.5. Объектный пул (Pool)
  1.6. Прототип (Prototype)
  1.7. Простая Фабрика (Simple Factory)
  1.8. Одиночка (Singleton)
  1.9. Статическая Фабрика (Static Factory)
  
2. Структурные шаблоны проектирования (Structural) - отвечают за построение удобных в поддержке иерархий классов.
  2.1. Адаптер (Adapter / Wrapper)
  2.2. Мост (Bridge)
  2.3. Компоновщик (Composite)
  2.4. Преобразователь Данных (Data Mapper)
  2.5. Декоратор (Decorator)
  2.6. Внедрение Зависимости (Dependency Injection)
  2.7. Фасад (Facade)
  2.8. Текучий Интерфейс (Fluent Interface)
  2.9. Приспособленец (Flyweight)
  2.10. Прокси (Proxy)
  2.11. Реестр (Registry)
  
3. Поведенческие шаблоны проектирования (Behavioral) - решают задачи эффективного и безопасного взаимодействия между объектами программы.
  3.1. Цепочка Обязанностей (Chain Of Responsibilities)
  3.2. Команда (Command)
  3.3. Итератор (Iterator)
  3.4. Посредник (Mediator)
  3.5. Хранитель (Memento)
  3.6. Объект Null (Null Object)
  3.7. Наблюдатель (Observer)
  3.8. Спецификация (Specification)
  3.9. Состояние (State)
  3.10. Стратегия (Strategy)
  3.11. Шаблонный Метод (Template Method)
  3.12. Посетитель (Visitor)


Задание №2.
Пункты реалицации паттерна "Фабричный метод":
- Привести все создаваемые продукты к общему интерфейсу.
- В классе, который производит продукты, создать пустой фабричный метод. В качестве возвращаемого типа указать общий интерфейс продукта.
- Пройдясь по коду класса и найдя все участки, создающие продукты. Поочерёдно заменить эти участки вызовами фабричного метода, перенося в него код создания различных продуктов.
- Для каждого типа продуктов завести подкласс и переопределить в нём фабричный метод. Затем переместить туда код создания соответствующего продукта из суперкласса.
- Если создаваемых продуктов слишком много для существующих подклассов создателя, можно подумать о введении параметров в фабричный метод, которые позволят возвращать различные продукты в пределах одного подкласса.
- Если после всех перемещений фабричный метод стал пустым, можете сделать его абстрактным.

Отличие от паттерна "Простая Фабрика" в том, что можно вынести реализацию создания объектов в подклассы.


Задание №3.
__get - будет выполнен при чтении данных из недоступных свойств.
__set - будет выполнен при записи данных в недоступные свойства.
__isset - отслеживает вызов функции на проверку существования и получает в качестве аргумента — название свойства.
__unset - будет отслеживать попытки очистить не публичный свойства класса.
__call - запускается при вызове недоступных методов в контексте объект.
__callStatic - запускается при вызове недоступных методов в статическом контексте.


Задание №4.
Популярные структуры данных из стандартной библиотеки PHP (SPL):
SplStack — используется для создания стэка. 
  Стек используется для обхода структур данных, например, дерево или граф.
SplQueue — используется для создания очередей.
  Очереди часто используются в программах для реализации буфера, в который можно положить элемент для последующей обработки, сохраняя порядок
  поступления.


Задание №5.
interface MyInt {
    public function funcI();
    private function funcP();
} 
class A {
    protected prop1;
    private prop2;

    function funcA(){
       return $this->prop2;
    }
}
class B extends A {
    function funcB(){
       return $this->prop1;
    }
}
class C extends B implements MyInt {
    function funcB(){
       return $this->prop1;
    }
    private function funcP(){
       return 123;
    }
}  
$b = new B();
$b->funcA();
$c = new C();
$c->funcI();